// extension/background.js
import { loadAsync, saveAsync } from "/utils/storage.js";
import { ensureFirebaseAuth } from "/utils/firebaseInit.js";


const NOTIF_META_PREFIX = "notif_meta_";
const ACTIVE_META_PREFIX = "active_notif_meta_";
const ALARM_PREFIX = "aeryth_";

// ======================= Alarm & Notification Helpers =======================

/** schedule alarms for a particular routine for upcoming days (n days ahead). */
async function scheduleAlarmsForRoutine(routine, daysAhead = 3) {
  try {
    if (!routine || !routine.startTime) return;
    const now = new Date();
    for (let i = 0; i < daysAhead; i++) {
      const d = new Date(now.getFullYear(), now.getMonth(), now.getDate() + i);
      const dayIso = d.toISOString().slice(0, 10);
      const daysMap = { Mon:1, Tue:2, Wed:3, Thu:4, Fri:5, Sat:6, Sun:0 };
      const wd = d.getDay();
      if (!routine.days || !routine.days.some(dd => daysMap[dd] === wd)) continue;

      const [hh, mm] = (routine.startTime || "00:00").split(":").map(Number);
      const when = new Date(d.getFullYear(), d.getMonth(), d.getDate(), hh, mm, 0, 0).getTime();
      if (when <= Date.now()) continue;

      const alarmName = `${ALARM_PREFIX}start_${routine.id}_${dayIso}_${when}`;
      const meta = {
        notifId: `aeryth-${routine.id}-${dayIso}-${when}`,
        routineId: routine.id,
        dateIso: dayIso,
        type: "start",
        message: `${routine.name}: time to start.`,
        iconUrl: "icons/icon48.png"
      };

      await chrome.storage.local.set({ [`${NOTIF_META_PREFIX}${alarmName}`]: meta });
      chrome.alarms.create(alarmName, { when });
    }
  } catch (e) {
    console.warn("scheduleAlarmsForRoutine failed", e);
  }
}

/** schedule end-of-routine alarms (e.g., at endTime) */
async function scheduleEndAlarmsForRoutine(routine, daysAhead = 3) {
  try {
    if (!routine || !routine.endTime) return;
    const now = new Date();
    for (let i = 0; i < daysAhead; i++) {
      const d = new Date(now.getFullYear(), now.getMonth(), now.getDate() + i);
      const dayIso = d.toISOString().slice(0, 10);
      const daysMap = { Mon:1, Tue:2, Wed:3, Thu:4, Fri:5, Sat:6, Sun:0 };
      const wd = d.getDay();
      if (!routine.days || !routine.days.some(dd => daysMap[dd] === wd)) continue;

      const [hh, mm] = (routine.endTime || "00:00").split(":").map(Number);
      const when = new Date(d.getFullYear(), d.getMonth(), d.getDate(), hh, mm, 0, 0).getTime();
      if (when <= Date.now()) continue;

      const alarmName = `${ALARM_PREFIX}end_${routine.id}_${dayIso}_${when}`;
      const meta = {
        notifId: `aeryth-end-${routine.id}-${dayIso}-${when}`,
        routineId: routine.id,
        dateIso: dayIso,
        type: "end",
        message: `${routine.name}: time's up â€” did you complete it?`,
        iconUrl: "icons/icon48.png"
      };

      await chrome.storage.local.set({ [`${NOTIF_META_PREFIX}${alarmName}`]: meta });
      chrome.alarms.create(alarmName, { when });
    }
  } catch (e) {
    console.warn("scheduleEndAlarmsForRoutine failed", e);
  }
}

/** build notification options for 'start' or 'end' */
function buildNotificationOptions(meta) {
  if (!meta) return null;
  if (meta.type === "start") {
    return {
      type: "basic",
      title: "Aeryth",
      message: meta.message || "Time to start your routine",
      iconUrl: meta.iconUrl || "icons/icon48.png",
      priority: 2,
      buttons: [
        { title: "Started" },
        { title: "Skipped" },
        { title: "2 mins" },
        { title: "5 mins" }
      ]
    };
  } else {
    return {
      type: "basic",
      title: "Aeryth",
      message: meta.message || "Did you complete it?",
      iconUrl: meta.iconUrl || "icons/icon48.png",
      priority: 2,
      buttons: [
        { title: "Completed" },
        { title: "Skipped" }
      ]
    };
  }
}

// ======================= Event handlers =======================

chrome.runtime.onInstalled.addListener(async () => {
  console.log("Aeryth background installed (Firebase version)");
  try {
    const routines = await loadAsync("aeryth_routines", []);
    for (const r of routines) {
      await scheduleAlarmsForRoutine(r, 3);
      await scheduleEndAlarmsForRoutine(r, 3);
    }
  } catch (e) {
    console.warn("onInstalled scheduling failed", e);
  }
});

chrome.runtime.onStartup.addListener(async () => {
  console.log("Aeryth background starting up (Firebase version)");
  try {
    const routines = await loadAsync("aeryth_routines", []);
    for (const r of routines) {
      await scheduleAlarmsForRoutine(r, 3);
      await scheduleEndAlarmsForRoutine(r, 3);
    }
  } catch (e) {
    console.warn("onStartup scheduling failed", e);
  }
});

// ======================= Notification logic =======================

// Alarm fired: create notification using metadata saved earlier
chrome.alarms.onAlarm.addListener(async (alarm) => {
  try {
    const metaKey = `${NOTIF_META_PREFIX}${alarm.name}`;
    const store = await new Promise(res => chrome.storage.local.get([metaKey], res));
    const meta = store[metaKey];
    if (!meta) {
      console.warn("No meta found for alarm", alarm.name);
      return;
    }
    const options = buildNotificationOptions(meta);
    if (!options) return;

    const notifId = meta.notifId || `aeryth-notif-${Date.now()}`;
    chrome.notifications.create(notifId, options, () => {});

    await new Promise(res => chrome.storage.local.set({ [`${ACTIVE_META_PREFIX}${notifId}`]: meta }, res));
  } catch (e) {
    console.error("onAlarm handler error", e);
  }
});

// Notification button clicks handler
chrome.notifications.onButtonClicked.addListener(async (notificationId, buttonIndex) => {
  try {
    const metaKey = `${ACTIVE_META_PREFIX}${notificationId}`;
    const store = await new Promise(res => chrome.storage.local.get([metaKey], res));
    const meta = store[metaKey];
    if (!meta) {
      chrome.notifications.clear(notificationId);
      return;
    }

    const { routineId, dateIso, type } = meta;
    let action = null;
    if (type === "start") {
      if (buttonIndex === 0) action = "started";
      if (buttonIndex === 1) action = "skipped";
      if (buttonIndex === 2) action = "snooze2";
      if (buttonIndex === 3) action = "snooze5";
    } else {
      if (buttonIndex === 0) action = "completed";
      if (buttonIndex === 1) action = "skipped";
    }

    // handle snooze
    if (action === "snooze2" || action === "snooze5") {
      const mins = action === "snooze2" ? 2 : 5;
      const newWhen = Date.now() + mins * 60000;
      const newAlarmName = `${ALARM_PREFIX}snooze_${routineId}_${dateIso}_${newWhen}`;
      const snoozeMeta = { ...meta, notifId: `${notificationId}-snooze-${mins}`, snooze: mins };
      await chrome.storage.local.set({ [`${NOTIF_META_PREFIX}${newAlarmName}`]: snoozeMeta });
      chrome.alarms.create(newAlarmName, { when: newWhen });
    } else {
      // record status & notif chat to Firestore
      const eventStatuses = await loadAsync("aeryth_event_statuses", {});
      const notifChats = await loadAsync("aeryth_notif_chats", {});
      const ts = new Date().toISOString();

      eventStatuses[routineId] = eventStatuses[routineId] || {};
      notifChats[routineId] = notifChats[routineId] || {};
      notifChats[routineId][dateIso] = notifChats[routineId][dateIso] || [];

      if (action === "started") eventStatuses[routineId][dateIso] = "in-progress";
      else if (action === "completed") eventStatuses[routineId][dateIso] = "completed";
      else if (action === "skipped") eventStatuses[routineId][dateIso] = "skipped";

      notifChats[routineId][dateIso].push({ from: "user", text: action, ts });

      await saveAsync("aeryth_event_statuses", eventStatuses);
      await saveAsync("aeryth_notif_chats", notifChats);
    }

    await chrome.storage.local.remove([metaKey]);
    chrome.notifications.clear(notificationId);
  } catch (e) {
    console.error("onButtonClicked error", e);
  }
});

chrome.notifications.onClosed.addListener(async (notificationId) => {
  try {
    const metaKey = `${ACTIVE_META_PREFIX}${notificationId}`;
    await chrome.storage.local.remove([metaKey]);
  } catch (e) {
    console.warn("onClosed cleanup failed", e);
  }
});
